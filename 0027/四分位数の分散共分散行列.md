---
jupyter:
  jupytext:
    formats: ipynb,md
    text_representation:
      extension: .md
      format_name: markdown
      format_version: '1.3'
      jupytext_version: 1.10.3
  kernelspec:
    display_name: Julia 1.7.1
    language: julia
    name: julia-1.7
---

# 四分位数の分布

* 黒木玄
* 2022-02-11

累積分布函数 $F(x)$ と密度函数 $p(x)$ を持つ分布のサイズ $n$ の標本の 25%, 50%, 75% 分位数をそれぞれ $Q_1, Q_2, Q_3$ と書く.

標本の四分位数の定義には揺れがあるが, その点を無視すれば, $(Q_1, Q_2, Q_3)$ の分布の確率測度は $\operatorname{Dirichlet}(n/4, n/4, n/4, n/4)$ 分布の $(t_1, t_2, t_3)$ ($t_i > 0$, $t_1+t_2+t_3<1$) に関する確率測度を $t_1 = F(q_1)$, $t_2 = F(q_2) - F(q_1)$, $t_3 = F(q_3) - F(q_2)$ で引き戻したものになる.

このことを使うと, Dirichlet分布の分散共分散行列を使って, 標本の四分位数 $Q_1, Q_2, Q_3$ の同時確率分布の分散共分散行列を書ける.

さらに, そのことを使えば $n$ が大きなときの正規分布近似も計算できる. 正規分布近似の分散共分散行列は

$$
a_i = F^{-1}(i/4), \quad
p_i = p(a_i) \quad
(i = 1,2,3)
$$

とおいたときの

$$
\frac{1}{16(n+1)}
\begin{bmatrix}
p_1^{-1} & & \\
& p_2^{-1} & \\
& & p_3^{-1} \\
\end{bmatrix}
\begin{bmatrix}
3 & 2 & 1 \\
2 & 4 & 2 \\
1 & 2 & 3 \\
\end{bmatrix}
\begin{bmatrix}
p_1^{-1} & & \\
& p_2^{-1} & \\
& & p_3^{-1} \\
\end{bmatrix}
$$

になる.  ここで出てきた行列 $\dfrac{1}{4}\begin{bmatrix}
3 & 2 & 1 \\
2 & 4 & 2 \\
1 & 2 & 3 \\
\end{bmatrix}$ は次の行列の逆行列として出てきた:
$$
\begin{bmatrix}
2 & -1 & 0 \\
-1 & 2 & -1 \\
0 & -1 & 2 \\
\end{bmatrix}
$$

具体的な公式については以下のコードを解読すれば分かるはず. 私が手計算で得た公式が間違っている可能性を心配していたが, 数値的に確認してみると, 十分に正しい公式を得ていそうなことがわかった.  Monte Carlo シミュレーションの結果とDirichlet分布の分散共分散行列を使って書いた公式を使って計算した結果とDirichlet分布の正規分布近似の分散共分散行列が近似的に一致していることが確認できた.

```julia
using LinearAlgebra
using StaticArrays
using Random
using Distributions
using StatsPlots
plot(Beta(100, 100); size=(300, 200))
```

```julia
function simquantile(; dist = Gamma(2, 1), n = 100, L = 10^5)
    Q = Matrix{Float64}(undef, L, 3)
    tmp = [Vector{Float64}(undef, n) for _ in 1:Threads.nthreads()]
    Threads.@threads for i in 1:L
        X = rand!(dist, tmp[Threads.threadid()])
        Q[i, :] .= quantile.(Ref(X), (0.25, 0.50, 0.75))
    end
    Q
end

Q_exactvalue(; dist = Gamma(2, 1)) = quantile.(dist, SVector(0.25, 0.50, 0.75))

function covQ_exactvalue(; dist = Gamma(2, 1), n = 100)
    dir = Dirichlet(SVector(n/4, n/4, n/4, n/4))
    ET = @view cov(dir)[1:3, 1:3]
    L = @SMatrix [
        1 0 0
        1 1 0
        1 1 1
    ]
    EQ = L * ET * transpose(L)
    a = SVector(quantile.(dist, (0.25, 0.50, 0.75))...)
    pinv = @. 1 / pdf(dist, a)
    Σ = Symmetric(diagm(pinv) * EQ * diagm(pinv))
end

function covQ_normalapprox(; dist = Gamma(2, 1), n = 100)
    A = 1/(16(n+1)) * @SMatrix [
        3 2 1
        2 4 2
        1 2 3
    ]
    a = SVector(quantile.(dist, (0.25, 0.50, 0.75))...)
    pinv = @. 1 / pdf(dist, a)
    Σ = Symmetric(diagm(pinv) * A * diagm(pinv))
end

function comparequantile(; dist = Gamma(2, 1), n = 100, L = 10^5)
    Q_exact = Q_exactvalue(; dist)
    covQ_exact = covQ_exactvalue(; dist, n)
    covQ_normal = covQ_normalapprox(; dist, n)
    
    Q = simquantile(; dist, n, L)
    Q_simulation = mean.(eachcol(Q))
    covQ_simulation = cov(Q)
    
    @show dist
    @show n
    @show L
    println()
    
    @show Q_exact
    @show Q_simulation
    println("relative error: ", Q_simulation ./ Q_exact .- 1)
    

    println("\ncov(Q) exact value:")
    Base.print_matrix(stdout, covQ_exact); flush(stdout)
    
    println("\n\ncov(Q) simulation:")
    Base.print_matrix(stdout, covQ_simulation); flush(stdout)
    println("\n\nrelative error from exact value:")
    Base.print_matrix(stdout, covQ_simulation ./ covQ_exact .- 1)
    
    println("\n\ncov(Q) normal approx:")
    Base.print_matrix(stdout, covQ_normal); flush(stdout)
    println("\n\nrelative error from exact value:")
    Base.print_matrix(stdout, covQ_normal ./ covQ_exact .- 1)
    println("\n\nrelative error to simulation:")
    Base.print_matrix(stdout, covQ_simulation ./ covQ_normal .- 1)
end
```

```julia
comparequantile(; dist = Normal(2, 1), n = 100)
```

```julia
comparequantile(; dist = Uniform(), n = 100)
```

```julia
comparequantile(; dist = Gamma(2, 1), n = 100)
```

```julia
comparequantile(; dist = Exponential(), n = 100)
```

```julia
comparequantile(; dist = LogNormal(), n = 100)
```

```julia
comparequantile(; dist = Gamma(2, 1), n = 10)
```

```julia
comparequantile(; dist = Gamma(2, 1), n = 20)
```

```julia
comparequantile(; dist = Gamma(2, 1), n = 40)
```

```julia
comparequantile(; dist = Gamma(2, 1), n = 80)
```

```julia
comparequantile(; dist = Gamma(2, 1), n = 160)
```

```julia

```
